<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Centro - Jogo Emocional</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
      #insight-box {
  position: fixed;
  top: 50%;
  left: 50%;
  display: block;
  transform: translate(-50%, -50%);
  max-width: 80vw;
  max-height: 80vh;
  overflow-y: auto;
  padding: 20px;
  background:#ffffffee; 
  color: #111;
  font-size: 1.2em;
  border-radius: 12px;
  text-align: center;
  z-index: 9999;
  opacity: 1;
  transition: opacity 0.5s ease;
}

#insight-box.hide {
  display: none;
  opacity: 0;
  transition: opacity 0.5s ease;

}

#insight-box button {
  margin-top: 15px;
  padding: 8px 16px;
  font-size: 1em;
  background: #111;
  color: #fff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
}
#autor{
  display: block;
  text-align: right;
  margin-right: 20px;
  font-style: italic;
}
  </style>
</head>
<body>
<canvas id="game"></canvas>
<div id="insight-box" class="hide">
  <div id="insight-text"></div>
  <div id="autor">Jesus</div>
  <button onclick="hideInsight()">Continuar</button>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let center = {
  x: canvas.width / 2,
  y: canvas.height / 2,
  r: 20,
  emoji: 'ðŸ§˜',
  emotionLevel: 1,
  colorHue: 240,
  insight: null,
  insightTimer: 0
};

let velocity = { x: 0, y: 0 };
let maxSpeed = 2;
let emotions = [];
let insights = [];
let frame = 0;
let recentSpeedAvg = 0;

const emotionPool = [
  { emoji: 'ðŸ§˜', intensity: 0, hue: 240 },
  { emoji: 'ðŸ™‚', intensity: 0, hue: 200 },
  { emoji: 'ðŸ˜Œ', intensity: 0, hue: 180 },
  { emoji: 'ðŸ˜¶', intensity: 1, hue: 160 },
  { emoji: 'ðŸ˜', intensity: 1, hue: 140 },
  { emoji: 'ðŸ˜•', intensity: 2, hue: 100 },
  { emoji: 'ðŸ˜¢', intensity: 3, hue: 60 },
  { emoji: 'ðŸ˜ ', intensity: 3, hue: 40 },
  { emoji: 'ðŸ˜­', intensity: 4, hue: 20 },
  { emoji: 'ðŸ˜¡', intensity: 4, hue: 10 },
  { emoji: 'ðŸ’”', intensity: 5, hue: 0 },
  { emoji: 'ðŸ˜±', intensity: 5, hue: 300 }
];

const mastersWisdom = [
  // BUDA
  {
    name: "Buda",
    icon: "ðŸ§˜",
    theme: "ImpermanÃªncia e LibertaÃ§Ã£o do Sofrimento",
    quotes: [
      "A dor Ã© inevitÃ¡vel, mas o sofrimento Ã© opcional.",
      "Todo sofrimento vem do apego Ã quilo que Ã© impermanente.",
      "Quando olhamos para os cinco agregados - forma, sensaÃ§Ã£o, percepÃ§Ã£o, formaÃ§Ãµes mentais e consciÃªncia - onde estÃ¡ esse 'eu' que sofre?",
      "O sofrimento surge da ilusÃ£o de separaÃ§Ã£o. Quando vemos atravÃ©s desta ilusÃ£o...",
      "Em minha investigaÃ§Ã£o, descobri que aquilo que chamamos 'eu' Ã© uma construÃ§Ã£o.",
      "A compaixÃ£o nasce quando reconhecemos que todos os seres estÃ£o apenas esquecidos de sua verdadeira natureza.",
      "O despertar nÃ£o Ã© conquistar algo novo, mas reconhecer o que sempre foi verdadeiro."
    ]
  },

  // JESUS
  {
    name: "Jesus",
    icon: "â¤ï¸",
    theme: "Amor Incondicional e Unidade Divina",
    quotes: [
      "Ame seus inimigos e ore por aqueles que os perseguem.",
      "O Reino dos CÃ©us estÃ¡ dentro de vocÃªs.",
      "O Pai e eu somos um.",
      "Quando o homem compreende que nÃ£o estÃ¡ separado da Fonte, que Ã© filho da mesma essÃªncia divina, toda busca externa perde sentido.",
      "O amor nÃ£o Ã© algo que conquistamos - Ã© o que somos.",
      "O que observo Ã© que o coraÃ§Ã£o humano busca constantemente algo fora de si mesmo quando o Reino jÃ¡ habita dentro dele.",
      "Descobrimos que nunca estivemos separados. O Reino sempre esteve aqui, no coraÃ§Ã£o da experiÃªncia presente."
    ]
  },

  // KRISHNAMURTI
  {
    name: "Krishnamurti",
    icon: "ðŸ§ ",
    theme: "PercepÃ§Ã£o Direta e Liberdade Mental",
    quotes: [
      "A capacidade de observar sem avaliar Ã© a mais alta forma de inteligÃªncia humana.",
      "O homem cria sistemas, mÃ©todos, tradiÃ§Ãµes... e depois se torna escravo deles. A prÃ³pria busca pode ser o obstÃ¡culo.",
      "No momento em que dizemos 'somos amor' ou 'somos um', jÃ¡ criamos uma divisÃ£o.",
      "A verdadeira percepÃ§Ã£o acontece quando essa divisÃ£o se dissolve completamente - sem mÃ©todo, sem prÃ¡tica, sem tempo.",
      "HÃ¡ o observador que diz isso e o observado. A verdadeira percepÃ§Ã£o acontece quando essa divisÃ£o se dissolve completamente.",
      "Essa descoberta nÃ£o pode ser um resultado de esforÃ§o ou tempo. Ã‰ uma percepÃ§Ã£o imediata, quando a mente para de projetar e simplesmente Ã©.",
      "A verdadeira liberdade comeÃ§a quando percebemos que nÃ£o somos nossos pensamentos."
    ]
  },

  // KEN WILBER
  {
    name: "Ken Wilber",
    icon: "ðŸŒ±",
    theme: "EvoluÃ§Ã£o da ConsciÃªncia e IntegraÃ§Ã£o",
    quotes: [
      "O desenvolvimento da consciÃªncia Ã© um processo de transcender e incluir.",
      "A consciÃªncia pode ter insights profundos nos estÃ¡gios superiores, mas ainda assim pode regredir.",
      "A integraÃ§Ã£o requer tanto transcendÃªncia quanto inclusÃ£o.",
      "HÃ¡ uma diferenÃ§a entre dissoluÃ§Ã£o temporÃ¡ria e estabilizaÃ§Ã£o dessa compreensÃ£o.",
      "Uma percepÃ§Ã£o que pode se manifestar em diferentes profundidades e nÃ­veis de estabilidade.",
      "Honrando tanto a dimensÃ£o transcendente quanto a evoluÃ§Ã£o da consciÃªncia atravÃ©s do tempo.",
      "A consciÃªncia evolui em espirais, sempre retornando aos mesmos temas em nÃ­veis mais profundos."
    ]
  },

  // ALAN WATTS
  {
    name: "Alan Watts",
    icon: "ðŸŽ­",
    theme: "Leveza e o Jogo Sagrado da ExistÃªncia",
    quotes: [
      "A vida Ã© um jogo cujo objetivo Ã© descobrir que Ã© um jogo.",
      "Ã‰ como tentar morder os prÃ³prios dentes, nÃ£o acham? O ego quer 'conseguir' o desapego.",
      "Quanto mais tentamos agarrar essa compreensÃ£o, mais ela escapa!",
      "Ã‰ como tentar segurar Ã¡gua com as mÃ£os abertas - sÃ³ funciona quando relaxamos completamente.",
      "A Ã¡gua nÃ£o 'tenta' ser molhada, as Ã¡rvores nÃ£o 'praticam' crescer.",
      "O despertar pode ser nossa natureza mais natural - sÃ³ precisamos parar de interferir.",
      "Quando deixamos de levar o ego tÃ£o a sÃ©rio, descobrimos uma leveza profunda."
    ]
  },

  // MOOJI
  {
    name: "Mooji",
    icon: "ðŸ‘ï¸",
    theme: "InvestigaÃ§Ã£o Direta do Ser",
    quotes: [
      "VocÃª nÃ£o Ã© uma pessoa que tem consciÃªncia. VocÃª Ã© a consciÃªncia na qual a pessoa aparece.",
      "Este mesmo que busca, este mesmo que sofre, este mesmo que quer se libertar... ele Ã© real?",
      "Quando vocÃªs param e realmente olham - sem conceitos, sem histÃ³ria - quem estÃ¡ aÃ­?",
      "Deixem-me perguntar: quem vai 'parar de interferir'? Quem vai 'praticar' ou 'nÃ£o praticar'?",
      "Quando realmente investigamos este 'eu', descobrimos que ele nunca teve existÃªncia independente.",
      "Para quem Ã© a liberaÃ§Ã£o?",
      "Quando relaxamos completamente, descobrimos que aquilo que sempre procuramos... somos nÃ³s mesmos.",
      "NÃ£o como pessoa, mas como a prÃ³pria consciÃªncia na qual todas as experiÃªncias aparecem e desaparecem."
    ]
  },

  // CONCLUSÃƒO UNIFICADA
  {
    name: "Todos os Mestres",
    icon: "ðŸŒŸ",
    theme: "Sabedoria Unificada",
    quotes: [
      "A verdade para a qual todos apontamos transcende palavras e conceitos.",
      "O sofrimento humano nasce da ilusÃ£o fundamental de separaÃ§Ã£o.",
      "Nunca houve alguÃ©m para ser liberado, pois nunca houve uma prisÃ£o real.",
      "A separaÃ§Ã£o Ã© uma miragem da mente.",
      "O que somos essencialmente - consciÃªncia pura, amor incondicional, presenÃ§a infinita - nunca nasceu e nunca morrerÃ¡.",
      "Nunca foi tocado pelo sofrimento e nunca precisou de salvaÃ§Ã£o.",
      "A compaixÃ£o nasce naturalmente desta compreensÃ£o.",
      "O despertar nÃ£o Ã© conquistar algo novo, mas reconhecer o que sempre foi verdadeiro.",
      "Todos os seres, em sua busca e sofrimento, estÃ£o apenas esquecidos de sua verdadeira natureza."
    ]
  }
];

// FunÃ§Ã£o para buscar citaÃ§Ãµes por mestre
function getQuotesByMaster(masterName) {
  return mastersWisdom.find(master => master.name === masterName);
}

// FunÃ§Ã£o para buscar citaÃ§Ãµes por tema
function getQuotesByTheme(theme) {
  return mastersWisdom.filter(master => 
    master.theme.toLowerCase().includes(theme.toLowerCase())
  );
}

// FunÃ§Ã£o para obter uma citaÃ§Ã£o aleatÃ³ria
function getRandomQuote() {
  const randomMaster = mastersWisdom[Math.floor(Math.random() * mastersWisdom.length)];
  const randomQuote = randomMaster.quotes[Math.floor(Math.random() * randomMaster.quotes.length)];
  return {
    master: randomMaster.name,
    icon: randomMaster.icon,
    theme: randomMaster.theme,
    quote: randomQuote
  };
}

// FunÃ§Ã£o para obter todas as citaÃ§Ãµes em formato linear
function getAllQuotes() {
  const allQuotes = [];
  mastersWisdom.forEach(master => {
    master.quotes.forEach(quote => {
      allQuotes.push({
        master: master.name,
        icon: master.icon,
        theme: master.theme,
        quote: quote
      });
    });
  });
  return allQuotes;
}

// FunÃ§Ã£o para buscar citaÃ§Ãµes por palavra-chave
function searchQuotes(keyword) {
  return getAllQuotes().filter(item => 
    item.quote.toLowerCase().includes(keyword.toLowerCase()) ||
    item.theme.toLowerCase().includes(keyword.toLowerCase())
  );
}

// Exemplos de uso:
console.log("CitaÃ§Ã£o de Buda:", getQuotesByMaster("Buda"));
console.log("CitaÃ§Ã£o aleatÃ³ria:", getRandomQuote());
console.log("Busca por 'amor':", searchQuotes("amor"));

/*
  "Tudo jÃ¡ estÃ¡ aqui.",
  "VocÃª nÃ£o Ã© seus pensamentos.",
  "O agora Ã© o Ãºnico tempo real.",
  "Sofrimento nasce do apego.",
  "O vazio Ã© paz disfarÃ§ada.",
  "VocÃª jÃ¡ Ã© completo.",
  "Quem Ã© vocÃª sem suas certezas?",
  "O dedo aponta para a lua, mas nÃ£o Ã© a lua.",
  "Nada Ã© permanente.",
  "VocÃª Ã© feito do mesmo cÃ³digo do universo.",
  "A vida Ã© um jogo, descubra que Ã© um jogo.",
  "A mente cria os muros do eu e do nÃ£o-eu.",
  "A aversÃ£o tambÃ©m Ã© apego disfarÃ§ado.",
  "Cortar lenha, carregar Ã¡gua.",
  "Ã€s vezes, tudo que precisamos Ã© respirar fundo.",
  "O vazio nÃ£o Ã© ausÃªncia. Ã‰ espaÃ§o para o todo.",
  "Desejar o que nÃ£o se tem, apegar-se ao que se tem: raÃ­zes do sofrimento.",
  "Quem sofre? Quem percebe?",
  "A memÃ³ria Ã© o retorno do personagem.",
  "VocÃª pode pintar sua realidade dentro de si."*/


function spawnEmotion() {
  if (center.emoji === 'ðŸ§˜' && velocity.x === 0 && velocity.y === 0 && isDragging == false) return;

  const possible = emotionPool.filter(e => {
    if (center.emotionLevel === 5) return e.intensity >= 3;
    if (center.emotionLevel === 4) return e.intensity >= 2;
    if (center.emotionLevel === 3) return e.intensity >= 1;
    if (center.emotionLevel <= 2) return true;
  });
  const emotion = possible[Math.floor(Math.random() * possible.length)];

  const side = ['top', 'bottom', 'left', 'right'][Math.floor(Math.random() * 4)];
  let x, y;
  if (side === 'top')    { x = Math.random() * canvas.width; y = -30; }
  if (side === 'bottom') { x = Math.random() * canvas.width; y = canvas.height + 30; }
  if (side === 'left')   { x = -30; y = Math.random() * canvas.height; }
  if (side === 'right')  { x = canvas.width + 30; y = Math.random() * canvas.height; }

  const speed = 0.5 + emotion.intensity * 0.5;
  const dx = center.x - x + (Math.random() - 0.5) * 80;
  const dy = center.y - y + (Math.random() - 0.5) * 80;
  const dist = Math.hypot(dx, dy);
  const vx = dx / dist * speed;
  const vy = dy / dist * speed;

  emotions.push({ x, y, r: 18, vx, vy, ...emotion });
}

function spawnInsight() {
  const msg = getRandomQuote()
  
  insights.push({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    r: 20,
    text: msg.quote,
    autor:msg.master
  });
}

function spawnInsightBox(msg, master) {

  const box = document.getElementById('insight-box');
  const text = document.getElementById('insight-text');
    const autor = document.getElementById('autor');

  text.innerText =  '"'+msg+'"';
  autor.innerText = master // "indefinido";
  box.classList.remove('hide');

  // Ocultar apÃ³s 7 segundos, a menos que o usuÃ¡rio clique em "Continuar"
  clearTimeout(box.dataset.timeout);
  box.dataset.timeout = setTimeout(() => {
    hideInsight();
  }, 7000);
}

function hideInsight() {
  const box = document.getElementById('insight-box');
  box.classList.add('hide');
  center.emoji = 'ðŸ§˜'
}

function drawCenter() {
  ctx.font = `${center.r * 1.5}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(center.emoji, center.x, center.y);

  if (center.insightTimer > 0 && center.insight) {

  }
}

function drawEmotions() {
  for (let e of emotions) {
    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(e.emoji, e.x, e.y);
  }
}

function drawInsights() {
  for (let i of insights) {
    ctx.beginPath();
    ctx.arc(i.x, i.y, i.r, 0, Math.PI * 2);
    ctx.fillStyle = 'white';
    ctx.fill();
    ctx.stroke();
  }
}

function updateEmotions() {
  for (let i = emotions.length - 1; i >= 0; i--) {
    const e = emotions[i];
    e.x += e.vx;
    e.y += e.vy;

    const dx = center.x - e.x;
    const dy = center.y - e.y;
    const dist = Math.hypot(dx, dy);

    const isInvulnerable = center.emoji === 'ðŸ§˜' && velocity.x === 0 && velocity.y === 0 && isDragging == false;

    if (!isInvulnerable && dist < center.r + e.r) {
      center.emoji = e.emoji;
      center.colorHue = e.hue;
      if (e.intensity >= 3) {
        center.r = Math.min(100, center.r + 2);
      } else {
        center.r = Math.max(10, center.r - 1);
      }
      center.emotionLevel = e.intensity;
      emotions.splice(i, 1);
    }

    if (e.x < -50 || e.x > canvas.width + 50 || e.y < -50 || e.y > canvas.height + 50) {
      emotions.splice(i, 1);
    }
  }
}

function updateInsights() {
  for (let i = insights.length - 1; i >= 0; i--) {
    const ins = insights[i];
    const dx = center.x - ins.x;
    const dy = center.y - ins.y;
    const dist = Math.hypot(dx, dy);
    if (dist < center.r + ins.r) {
      center.insight = ins.text;
      center.insightTimer = 800;
      spawnInsightBox(ins.text, ins.autor)
      insights.splice(i, 1);
    }
  }
  if (center.insightTimer > 0) center.insightTimer--;
}

function updateCenter() {
  center.x += velocity.x;
  center.y += velocity.y;
  center.x = Math.max(center.r, Math.min(canvas.width - center.r, center.x));
  center.y = Math.max(center.r, Math.min(canvas.height - center.r, center.y));

  const speed = Math.hypot(velocity.x, velocity.y);
  recentSpeedAvg = recentSpeedAvg * 0.95 + speed * 0.05;
}

function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (frame % (20 + center.emotionLevel * 10) === 0) spawnEmotion();
  if (frame % 500 === 0) spawnInsight();

  document.body.style.backgroundColor = `hsl(${center.colorHue}, 50%, 18%)`;

  drawCenter();
  drawEmotions();
  drawInsights();
  updateEmotions();
  updateInsights();
  updateCenter();
  frame++;
}
setInterval(() => loop(), 1000 / 60);

const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

function handleInput() {
  velocity.x = 0;
  velocity.y = 0;
  if (keys['ArrowUp'] || keys['w']) velocity.y = -maxSpeed;
  if (keys['ArrowDown'] || keys['s']) velocity.y = maxSpeed;
  if (keys['ArrowLeft'] || keys['a']) velocity.x = -maxSpeed;
  if (keys['ArrowRight'] || keys['d']) velocity.x = maxSpeed;
}


let isDragging = false;
let lastTouch = null;

canvas.addEventListener('mousedown', (e) => {
  isDragging = true;
  lastTouch = { x: e.clientX, y: e.clientY };
});

canvas.addEventListener('mousemove', (e) => {
  if (isDragging) {
    const dx = e.clientX - lastTouch.x;
    const dy = e.clientY - lastTouch.y;
    center.x += dx;
    center.y += dy;
    lastTouch = { x: e.clientX, y: e.clientY };
  }
});

canvas.addEventListener('mouseup', () => {
  isDragging = false;
});

canvas.addEventListener('touchstart', (e) => {
  if (e.touches.length === 1) {
    isDragging = true;
    lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }
});

canvas.addEventListener('touchmove', (e) => {
  if (isDragging && e.touches.length === 1) {
    const dx = e.touches[0].clientX - lastTouch.x;
    const dy = e.touches[0].clientY - lastTouch.y;
    center.x += dx;
    center.y += dy;
    lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }
});

canvas.addEventListener('touchend', () => {
  isDragging = false;
});


setInterval(handleInput, 16);
loop();
</script>
</body>
</html>
