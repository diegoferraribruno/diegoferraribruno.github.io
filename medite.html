<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Centro - Jogo Emocional</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
      #insight-box {
  position: fixed;
  top: 50%;
  left: 50%;
  display: block;
  transform: translate(-50%, -50%);
  max-width: 80vw;
  max-height: 80vh;
  overflow-y: auto;
  padding: 20px;
  background:#ffffffee; 
  color: #111;
  font-size: 1.2em;
  border-radius: 12px;
  text-align: center;
  z-index: 9999;
  opacity: 1;
  transition: opacity 0.5s ease;
}

#insight-box.hide {
  display: none;
  opacity: 0;
  transition: opacity 0.5s ease;

}

#insight-box button {
  margin-top: 15px;
  padding: 8px 16px;
  font-size: 1em;
  background: #111;
  color: #fff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
}
#autor{
  display: block;
  text-align: right;
  margin-right: 20px;
  font-style: italic;
}
  </style>
</head>
<body>
<canvas id="game"></canvas>
<div id="insight-box" class="hide">
  <div id="insight-text"></div>
  <div id="autor">Jesus</div>
  <button onclick="hideInsight()">Continuar</button>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let center = {
  x: canvas.width / 2,
  y: canvas.height / 2,
  r: 20,
  emoji: 'üßò',
  emotionLevel: 1,
  colorHue: 240,
  insight: null,
  insightTimer: 0
};

let velocity = { x: 0, y: 0 };
let maxSpeed = 2;
let emotions = [];
let insights = [];
let frame = 0;
let recentSpeedAvg = 0;

const emotionPool = [
  { emoji: 'üßò', intensity: 0, hue: 240 },
  { emoji: 'üôÇ', intensity: 0, hue: 200 },
  { emoji: 'üòå', intensity: 0, hue: 180 },
  { emoji: 'üò∂', intensity: 1, hue: 160 },
  { emoji: 'üòê', intensity: 1, hue: 140 },
  { emoji: 'üòï', intensity: 2, hue: 100 },
  { emoji: 'üò¢', intensity: 3, hue: 60 },
  { emoji: 'üò†', intensity: 3, hue: 40 },
  { emoji: 'üò≠', intensity: 4, hue: 20 },
  { emoji: 'üò°', intensity: 4, hue: 10 },
  { emoji: 'üíî', intensity: 5, hue: 0 },
  { emoji: 'üò±', intensity: 5, hue: 300 }
];

const mastersWisdom = [
  // BUDA
  {
    name: "Buda",
    icon: "üßò",
    theme: "Imperman√™ncia e Liberta√ß√£o do Sofrimento",
    quotes: [
      "A dor √© inevit√°vel, mas o sofrimento √© opcional.",
      "Todo sofrimento vem do apego √†quilo que √© impermanente.",
      "Quando olhamos para os cinco agregados - forma, sensa√ß√£o, percep√ß√£o, forma√ß√µes mentais e consci√™ncia - onde est√° esse 'eu' que sofre?",
      "O sofrimento surge da ilus√£o de separa√ß√£o. Quando vemos atrav√©s desta ilus√£o...",
      "Em minha investiga√ß√£o, descobri que aquilo que chamamos 'eu' √© uma constru√ß√£o.",
      "A compaix√£o nasce quando reconhecemos que todos os seres est√£o apenas esquecidos de sua verdadeira natureza.",
      "O despertar n√£o √© conquistar algo novo, mas reconhecer o que sempre foi verdadeiro."
    ]
  },

  // JESUS
  {
    name: "Jesus",
    icon: "‚ù§Ô∏è",
    theme: "Amor Incondicional e Unidade Divina",
    quotes: [
      "Ame seus inimigos e ore por aqueles que os perseguem.",
      "O Reino dos C√©us est√° dentro de voc√™s.",
      "O Pai e eu somos um.",
      "Quando o homem compreende que n√£o est√° separado da Fonte, que √© filho da mesma ess√™ncia divina, toda busca externa perde sentido.",
      "O amor n√£o √© algo que conquistamos - √© o que somos.",
      "O que observo √© que o cora√ß√£o humano busca constantemente algo fora de si mesmo quando o Reino j√° habita dentro dele.",
      "Descobrimos que nunca estivemos separados. O Reino sempre esteve aqui, no cora√ß√£o da experi√™ncia presente."
    ]
  },

  // KRISHNAMURTI
  {
    name: "Krishnamurti",
    icon: "üß†",
    theme: "Percep√ß√£o Direta e Liberdade Mental",
    quotes: [
      "A capacidade de observar sem avaliar √© a mais alta forma de intelig√™ncia humana.",
      "O homem cria sistemas, m√©todos, tradi√ß√µes... e depois se torna escravo deles. A pr√≥pria busca pode ser o obst√°culo.",
      "No momento em que dizemos 'somos amor' ou 'somos um', j√° criamos uma divis√£o.",
      "A verdadeira percep√ß√£o acontece quando essa divis√£o se dissolve completamente - sem m√©todo, sem pr√°tica, sem tempo.",
      "H√° o observador que diz isso e o observado. A verdadeira percep√ß√£o acontece quando essa divis√£o se dissolve completamente.",
      "Essa descoberta n√£o pode ser um resultado de esfor√ßo ou tempo. √â uma percep√ß√£o imediata, quando a mente para de projetar e simplesmente √©.",
      "A verdadeira liberdade come√ßa quando percebemos que n√£o somos nossos pensamentos."
    ]
  },

  // KEN WILBER
  {
    name: "Ken Wilber",
    icon: "üå±",
    theme: "Evolu√ß√£o da Consci√™ncia e Integra√ß√£o",
    quotes: [
      "O desenvolvimento da consci√™ncia √© um processo de transcender e incluir.",
      "A consci√™ncia pode ter insights profundos nos est√°gios superiores, mas ainda assim pode regredir.",
      "A integra√ß√£o requer tanto transcend√™ncia quanto inclus√£o.",
      "H√° uma diferen√ßa entre dissolu√ß√£o tempor√°ria e estabiliza√ß√£o dessa compreens√£o.",
      "Uma percep√ß√£o que pode se manifestar em diferentes profundidades e n√≠veis de estabilidade.",
      "Honrando tanto a dimens√£o transcendente quanto a evolu√ß√£o da consci√™ncia atrav√©s do tempo.",
      "A consci√™ncia evolui em espirais, sempre retornando aos mesmos temas em n√≠veis mais profundos."
    ]
  },

  // ALAN WATTS
  {
    name: "Alan Watts",
    icon: "üé≠",
    theme: "Leveza e o Jogo Sagrado da Exist√™ncia",
    quotes: [
      "A vida √© um jogo cujo objetivo √© descobrir que √© um jogo.",
      "√â como tentar morder os pr√≥prios dentes, n√£o acham? O ego quer 'conseguir' o desapego.",
      "Quanto mais tentamos agarrar essa compreens√£o, mais ela escapa!",
      "√â como tentar segurar √°gua com as m√£os abertas - s√≥ funciona quando relaxamos completamente.",
      "A √°gua n√£o 'tenta' ser molhada, as √°rvores n√£o 'praticam' crescer.",
      "O despertar pode ser nossa natureza mais natural - s√≥ precisamos parar de interferir.",
      "Quando deixamos de levar o ego t√£o a s√©rio, descobrimos uma leveza profunda."
    ]
  },

  // MOOJI
  {
    name: "Mooji",
    icon: "üëÅÔ∏è",
    theme: "Investiga√ß√£o Direta do Ser",
    quotes: [
      "Voc√™ n√£o √© uma pessoa que tem consci√™ncia. Voc√™ √© a consci√™ncia na qual a pessoa aparece.",
      "Este mesmo que busca, este mesmo que sofre, este mesmo que quer se libertar... ele √© real?",
      "Quando voc√™s param e realmente olham - sem conceitos, sem hist√≥ria - quem est√° a√≠?",
      "Deixem-me perguntar: quem vai 'parar de interferir'? Quem vai 'praticar' ou 'n√£o praticar'?",
      "Quando realmente investigamos este 'eu', descobrimos que ele nunca teve exist√™ncia independente.",
      "Para quem √© a libera√ß√£o?",
      "Quando relaxamos completamente, descobrimos que aquilo que sempre procuramos... somos n√≥s mesmos.",
      "N√£o como pessoa, mas como a pr√≥pria consci√™ncia na qual todas as experi√™ncias aparecem e desaparecem."
    ]
  },

  // CONCLUS√ÉO UNIFICADA
  {
    name: "Todos os Mestres",
    icon: "üåü",
    theme: "Sabedoria Unificada",
    quotes: [
      "A verdade para a qual todos apontamos transcende palavras e conceitos.",
      "O sofrimento humano nasce da ilus√£o fundamental de separa√ß√£o.",
      "Nunca houve algu√©m para ser liberado, pois nunca houve uma pris√£o real.",
      "A separa√ß√£o √© uma miragem da mente.",
      "O que somos essencialmente - consci√™ncia pura, amor incondicional, presen√ßa infinita - nunca nasceu e nunca morrer√°.",
      "Nunca foi tocado pelo sofrimento e nunca precisou de salva√ß√£o.",
      "A compaix√£o nasce naturalmente desta compreens√£o.",
      "O despertar n√£o √© conquistar algo novo, mas reconhecer o que sempre foi verdadeiro.",
      "Todos os seres, em sua busca e sofrimento, est√£o apenas esquecidos de sua verdadeira natureza."
    ]
  }
];

// Fun√ß√£o para buscar cita√ß√µes por mestre
function getQuotesByMaster(masterName) {
  return mastersWisdom.find(master => master.name === masterName);
}

// Fun√ß√£o para buscar cita√ß√µes por tema
function getQuotesByTheme(theme) {
  return mastersWisdom.filter(master => 
    master.theme.toLowerCase().includes(theme.toLowerCase())
  );
}

// Fun√ß√£o para obter uma cita√ß√£o aleat√≥ria
function getRandomQuote() {
  const randomMaster = mastersWisdom[Math.floor(Math.random() * mastersWisdom.length)];
  const randomQuote = randomMaster.quotes[Math.floor(Math.random() * randomMaster.quotes.length)];
  return {
    master: randomMaster.name,
    icon: randomMaster.icon,
    theme: randomMaster.theme,
    quote: randomQuote
  };
}

// Fun√ß√£o para obter todas as cita√ß√µes em formato linear
function getAllQuotes() {
  const allQuotes = [];
  mastersWisdom.forEach(master => {
    master.quotes.forEach(quote => {
      allQuotes.push({
        master: master.name,
        icon: master.icon,
        theme: master.theme,
        quote: quote
      });
    });
  });
  return allQuotes;
}

// Fun√ß√£o para buscar cita√ß√µes por palavra-chave
function searchQuotes(keyword) {
  return getAllQuotes().filter(item => 
    item.quote.toLowerCase().includes(keyword.toLowerCase()) ||
    item.theme.toLowerCase().includes(keyword.toLowerCase())
  );
}

// Exemplos de uso:
console.log("Cita√ß√£o de Buda:", getQuotesByMaster("Buda"));
console.log("Cita√ß√£o aleat√≥ria:", getRandomQuote());
console.log("Busca por 'amor':", searchQuotes("amor"));

/*
  "Tudo j√° est√° aqui.",
  "Voc√™ n√£o √© seus pensamentos.",
  "O agora √© o √∫nico tempo real.",
  "Sofrimento nasce do apego.",
  "O vazio √© paz disfar√ßada.",
  "Voc√™ j√° √© completo.",
  "Quem √© voc√™ sem suas certezas?",
  "O dedo aponta para a lua, mas n√£o √© a lua.",
  "Nada √© permanente.",
  "Voc√™ √© feito do mesmo c√≥digo do universo.",
  "A vida √© um jogo, descubra que √© um jogo.",
  "A mente cria os muros do eu e do n√£o-eu.",
  "A avers√£o tamb√©m √© apego disfar√ßado.",
  "Cortar lenha, carregar √°gua.",
  "√Äs vezes, tudo que precisamos √© respirar fundo.",
  "O vazio n√£o √© aus√™ncia. √â espa√ßo para o todo.",
  "Desejar o que n√£o se tem, apegar-se ao que se tem: ra√≠zes do sofrimento.",
  "Quem sofre? Quem percebe?",
  "A mem√≥ria √© o retorno do personagem.",
  "Voc√™ pode pintar sua realidade dentro de si."*/


function spawnEmotion() {
  if (center.emoji === 'üßò' && velocity.x === 0 && velocity.y === 0 && isDragging == false) return;

  const possible = emotionPool.filter(e => {
    if (center.emotionLevel === 5) return e.intensity >= 3;
    if (center.emotionLevel === 4) return e.intensity >= 2;
    if (center.emotionLevel === 3) return e.intensity >= 1;
    if (center.emotionLevel <= 2) return true;
  });
  const emotion = possible[Math.floor(Math.random() * possible.length)];

  const side = ['top', 'bottom', 'left', 'right'][Math.floor(Math.random() * 4)];
  let x, y;
  if (side === 'top')    { x = Math.random() * canvas.width; y = -30; }
  if (side === 'bottom') { x = Math.random() * canvas.width; y = canvas.height + 30; }
  if (side === 'left')   { x = -30; y = Math.random() * canvas.height; }
  if (side === 'right')  { x = canvas.width + 30; y = Math.random() * canvas.height; }

  const speed = 0.5 + emotion.intensity * 0.5;
  const dx = center.x - x + (Math.random() - 0.5) * 80;
  const dy = center.y - y + (Math.random() - 0.5) * 80;
  const dist = Math.hypot(dx, dy);
  const vx = dx / dist * speed;
  const vy = dy / dist * speed;

  emotions.push({ x, y, r: 18, vx, vy, ...emotion });
}

function spawnInsight() {
  const msg = getRandomQuote()
  
  insights.push({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    r: 20,
    text: msg.quote,
    autor:msg.master
  });
}

function spawnInsightBox(msg, master) {

  const box = document.getElementById('insight-box');
  const text = document.getElementById('insight-text');
    const autor = document.getElementById('autor');

  text.innerText =  '"'+msg+'"';
  autor.innerText = master // "indefinido";
  box.classList.remove('hide');

  // Ocultar ap√≥s 7 segundos, a menos que o usu√°rio clique em "Continuar"
  clearTimeout(box.dataset.timeout);
  box.dataset.timeout = setTimeout(() => {
    hideInsight();
  }, 7000);
}

function hideInsight() {
  const box = document.getElementById('insight-box');
  box.classList.add('hide');
  center.emoji = 'üßò'
}

function drawCenter() {
  ctx.font = `${center.r * 1.5}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(center.emoji, center.x, center.y);

  if (center.insightTimer > 0 && center.insight) {

  }
}

function drawEmotions() {
  for (let e of emotions) {
    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(e.emoji, e.x, e.y);
  }
}

function drawInsights() {
  for (let i of insights) {
    ctx.beginPath();
    ctx.arc(i.x, i.y, i.r, 0, Math.PI * 2);
    ctx.fillStyle = 'white';
    ctx.fill();
    ctx.stroke();
  }
}

function updateEmotions() {
  for (let i = emotions.length - 1; i >= 0; i--) {
    const e = emotions[i];
    e.x += e.vx;
    e.y += e.vy;

    const dx = center.x - e.x;
    const dy = center.y - e.y;
    const dist = Math.hypot(dx, dy);

    const isInvulnerable = center.emoji === 'üßò' && velocity.x === 0 && velocity.y === 0 && isDragging == false;

    if (!isInvulnerable && dist < center.r + e.r) {
      center.emoji = e.emoji;
      center.colorHue = e.hue;
      if (e.intensity >= 3) {
        center.r = Math.min(100, center.r + 2);
      } else {
        center.r = Math.max(10, center.r - 1);
      }
      center.emotionLevel = e.intensity;
      emotions.splice(i, 1);
    }

    if (e.x < -50 || e.x > canvas.width + 50 || e.y < -50 || e.y > canvas.height + 50) {
      emotions.splice(i, 1);
    }
  }
}

function updateInsights() {
  for (let i = insights.length - 1; i >= 0; i--) {
    const ins = insights[i];
    const dx = center.x - ins.x;
    const dy = center.y - ins.y;
    const dist = Math.hypot(dx, dy);
    if (dist < center.r + ins.r) {
      center.insight = ins.text;
      center.insightTimer = 800;
      spawnInsightBox(ins.text, ins.autor)
      insights.splice(i, 1);
    }
  }
  if (center.insightTimer > 0) center.insightTimer--;
}

function updateCenter() {
  center.x += velocity.x;
  center.y += velocity.y;
  center.x = Math.max(center.r, Math.min(canvas.width - center.r, center.x));
  center.y = Math.max(center.r, Math.min(canvas.height - center.r, center.y));

  const speed = Math.hypot(velocity.x, velocity.y);
  recentSpeedAvg = recentSpeedAvg * 0.95 + speed * 0.05;
}

function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (frame % (20 + center.emotionLevel * 10) === 0) spawnEmotion();
  if (frame % 500 === 0) spawnInsight();

  document.body.style.backgroundColor = `hsl(${center.colorHue}, 50%, 18%)`;

  drawCenter();
  drawEmotions();
  drawInsights();
  updateEmotions();
  updateInsights();
  updateCenter();
  frame++;
}
setInterval(() => loop(), 1000 / 60);

const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

function handleInput() {
  velocity.x = 0;
  velocity.y = 0;
  if (keys['ArrowUp'] || keys['w']) velocity.y = -maxSpeed;
  if (keys['ArrowDown'] || keys['s']) velocity.y = maxSpeed;
  if (keys['ArrowLeft'] || keys['a']) velocity.x = -maxSpeed;
  if (keys['ArrowRight'] || keys['d']) velocity.x = maxSpeed;
}


let isDragging = false;
let lastTouch = null;

canvas.addEventListener('mousedown', (e) => {
  isDragging = true;
  lastTouch = { x: e.clientX, y: e.clientY };
});

canvas.addEventListener('mousemove', (e) => {
  if (isDragging) {
    const dx = e.clientX - lastTouch.x;
    const dy = e.clientY - lastTouch.y;
    center.x += dx;
    center.y += dy;
    lastTouch = { x: e.clientX, y: e.clientY };
  }
});

canvas.addEventListener('mouseup', () => {
  isDragging = false;
});

canvas.addEventListener('touchstart', (e) => {
  if (e.touches.length === 1) {
    isDragging = true;
    lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }
});

canvas.addEventListener('touchmove', (e) => {
  if (isDragging && e.touches.length === 1) {
    const dx = e.touches[0].clientX - lastTouch.x;
    const dy = e.touches[0].clientY - lastTouch.y;
    center.x += dx;
    center.y += dy;
    lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }
});

canvas.addEventListener('touchend', () => {
  isDragging = false;
});


setInterval(handleInput, 16);
loop();
</script>
</body>
</html>
