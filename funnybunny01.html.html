<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FUNNY bUNNY</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
        }
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 10px;
            max-width: 800px;
            width: 100%;
            text-align: center;
        }
        h1 {
            color: #4a5568;
            font-size: 1.6em;
        }
        .mode-selector {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }
        .mode-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 1.1em;
        }
        .mode-btn.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        .mode-btn:not(.active) {
            background: #e2e8f0;
            color: #4a5568;
        }
        .canvas-container {
            position: relative;
            margin: 20px auto;
            border: 3px solid #3498db;
            border-radius: 15px;
            background: #f8f9fa;
            overflow: hidden;
            width: 320px;
            height: 320px;
        }
        #canvas {
            display: block;
            cursor:none;
            background: transparent;
        }
        .controls {
            margin: 15px 0;
        }
        button {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .btn-primary { background: linear-gradient(45deg, #3498db, #2980b9); color: white; }
        .btn-success { background: linear-gradient(45deg, #27ae60, #2ecc71); color: white; }
        .btn-warning { background: linear-gradient(45deg, #f39c12, #e67e22); color: white; }
        .btn-danger { background: linear-gradient(45deg, #e74c3c, #c0392b); color: white; }
        .btn-secondary { background: linear-gradient(45deg, #95a5a6, #7f8c8d); color: white; }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }
        .letter-selector {
            display: block;
            margin: 15px 0;
            flex-wrap: wrap;
            max-height: 150px;
            overflow: auto;
            padding: 6px;
        }
        .letter-btn {
            border: none;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #4a5568;
        }
        .letter-btn:hover, .letter-btn.active {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            transform: scale(1.1);
        }
        .letter-btn.completed {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
        }
        .current-letter {
            font-size: 4em;
            color: #3498db;
            font-weight: bold;
            margin: 15px 0;
        }
        .status, .feedback {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 15px;
            margin: 15px 0;
            color: #2c3e50;
            font-weight: bold;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            width: 0%;
            transition: width 0.5s ease;
        }
        .success { color: #38a169; }
        .error { color: #e53e3e; }
        .info { color: #3182ce; }
        .hidden { display: none; }
        .stroke-list {
            text-align: left;
            max-height: 150px;
            overflow-y: auto;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 10px;
            margin: 15px 0;
            font-size: 0.9em;
        }
        .recording-indicator {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
            color: #e74c3c;
            font-weight: bold;
        }
        .recording-indicator.active { display: flex; }
        .pulse {
            width: 12px;
            height: 12px;
            background: #e74c3c;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
        @keyframes celebration {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .celebrate { animation: celebration 0.6s ease-in-out; }
        
        .popup-menu {
            position: absolute;
            background: white;
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 1000;
            min-width: 140px;
            opacity: 0;
            visibility: hidden;
            transform: scale(0.8);
            transition: all 0.2s ease;
        }

        .popup-menu.show {
            opacity: 1;
            visibility: visible;
            transform: scale(1);
        }

        .popup-menu-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background 0.2s ease;
            font-size: 14px;
        }

        .popup-menu-item:last-child {
            border-bottom: none;
        }

        .popup-menu-item:hover {
            background: #f5f5f5;
        }

        .popup-menu-item.move-left {
            color: #2196F3;
        }

        .popup-menu-item.move-right {
            color: #2196F3;
        }

        .popup-menu-item.rename {
            color: #FF9800;
        }

        .popup-menu-item.delete {
            color: #f44336;
        }

        .popup-menu-item.disabled {
            color: #ccc;
            cursor: not-allowed;
        }

        .popup-menu-item.disabled:hover {
            background: transparent;
        }

        .menu-icon {
            margin-right: 8px;
            font-weight: bold;
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
            display: none;
        }
        .floating{
            position: fixed;
            bottom: 10px;
            left: auto;
            width: 320px;
            height: 220px;
            z-index: 999;
            background: #f5f5f5;
            border-radius: 20px;
            border-color: #2980b9;
            border-width: 2px;
            border-style: dashed;
            padding: 10px;
        }
      
canvas:hover{
    cursor: none;
}

#cursor {
pointer-events: none;
position: absolute; 
  display: block;
  font-size: 24px;
}
#bhead{
    display: block;
    margin-left: -6px;
    margin-top: -40px;
    z-index: -1;
    
}
        
    </style>
</head>
<body>
    <div id="intro" style="position:fixed; top:0; left:0; width:100%; height:100%; background:#fff; z-index:9999; display:flex; align-items:center; justify-content:center; flex-direction:column; text-align:center; padding:20px;">
  <h2 style="font-size:2em;">üêáüíå Mensagem do Funny Bunny</h2>
  <p style="font-size:1.2em; max-width:500px;">Seu coelhinho passou o dia sozinho‚Ä¶ e aprendeu a escrever!<br><br>
  Ajude-o a completar seus pulinhos pelo caminho desenhado e descubra a mensagem nos coc√¥s de coelho üí©!</p>
  <button onclick="startGame()" class="btn-primary" style="margin-top:20px;">Come√ßar üêæ</button>

<P>O crie seu proprio caminho!
    <br/>
            <button class="mode-btn" onclick="startcreative()">üêáüí© Criar</button>
</P>
</div>

    <div class="container">
        <h1>üêáFUNNYüí©BUNNY</h1>
        <br>
        <div class="mode-selector">
            <button class="mode-btn active" onclick="setMode('play')">üéÆ Jogar</button>
            <button class="mode-btn" onclick="setMode('create')">üêáüí© Criar</button>
        </div>      
        
        <div class="canvas-container">
            <canvas id="canvas" width="320" height="320"></canvas>
        </div>
         <div id="playMode">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="feedback" id="feedback">Escolha uma arte e comece a desenhar!</div>
        </div>
        <div class="controls" id="playControls">
            <button class="btn-secondary" onclick="recomecar()">recome√ßar</button>
            <button class="btn-success hidden" onclick="nextLetter()" id="nextBtn">Pr√≥ximo</button>
         </div>

        <div class="controls hidden" id="createControls">
            <div style="margin: 10px 0;">
                <button class="btn-warning" onclick="toggleEraseMode()" id="eraseModeBtn">üóëÔ∏è</button>
                
                <label>Tamanho: </label>
                <input type="range" id="eraseRadiusSlider" min="10" max="50" value="25" 
                oninput="updateEraseRadius(this.value)" style="width: 100px;">
                <span id="eraseRadiusValue">25px</span>
                <button class="btn-danger" onclick="newLetter()">üóëÔ∏èApagar tudo</button>
        </div>
         <div style="margin: 10px 0;">
            <button class="btn-warning" onclick="promptForKeystroke()">Nova arte</button>
            <button class="btn-warning" onclick="newAlphabet('a')">a-z</button>
            <button class="btn-warning" onclick="newAlphabet('A')">A-Z</button>
        </div>
            <div class="letter-selector" id="letterSelector"></div>
            
           <div style="display: block; margin-top: 15px;">
            <button class="btn-primary" onclick="exportJSON()">Exportar</button>
            <button class="btn-primary" onclick="document.getElementById('importFile').click()">Importar</button>
</div>
            <br />
           <div style="display: block; margin-top: 15px;">
           <button class="btn-success" onclick="exportAllLetters()">C√≥digo-fonte</button>  
           <button onclick="toggleManualImport()" class="btn-success">Colar</button>
        </div>
            <input type="file" id="importFile" accept=".json" style="display:none" />
              <div id="menucolar">
                  <div id="manualImportArea" class="floating" style="display:none; margin-top:10px;">
                      <textarea id="manualImportText" placeholder="Cole o conte√∫do JSON aqui..." 
                      style="width:100%; height:100px;"></textarea>
                      <button onclick="processManualImport()">Importar Texto</button>
                       <button class="copy-btn" onclick="setHidden('manualImportArea')">fechar</button>
                    </div>
            </div>
          <div class="output-area floating" id="outputArea" style="display: none;">
              <h4>C√≥digo gerado</h4>
              <div id="generatedCode" style="display: block; height: 100px; overflow: auto;"></div>
              <button class="copy-btn" onclick="copyToClipboard()">Copiar o C√≥digo</button>
              <button class="copy-btn" onclick="setHidden('outputArea')">fechar</button>
            </div>
         <div id="createMode" class="hidden">
            
           
            <div class="current-letter hidden" id="currentLetter">a</div>
             <div class="stroke-list hidden" id="strokeList">
                    <div><strong>Arte Atual:</strong> <span id="statusLetter">a</span></div>
            <h4>Tra√ßos Gravados:<span id="strokeCount">0</span></h4>
            <div id="strokes">Nenhum tra√ßo gravado ainda</div>
        </div>
            <div class="recording-indicator hidden" id="recordingIndicator">
                <div class="pulse"></div>
                <span>Gravando tra√ßo... Desenhe no canvas</span>
            </div>
          
       
        </div>

      </div>

     
    </div>
    
 <div class="popup-overlay" id="popupOverlay"></div>
 <div id="cursor"><div id="bboddy">üêá</div><div id="bhead">üê∞</div></div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let currentMode = 'play';
        let currentLetter = 'a';
        let isDrawing = false;
        let isRecording = false;
        let currentStroke = [];
        let currentPath = [];
        let completedSegments = [];
        let showingGuide = false;
      
        let currentPathIndex = 0;
        let pathStarted = false;
        let pathDirection = 1;

        let isEraseMode = false;
        let eraseRadius = 25;
       
        let longPressTimer = null;
        let isLongPress = false;
        let currentPopupMenu = null;

        // Animation variables
        let segmentRevealStep = 5;
let currentRevealPoints = segmentRevealStep;
let animationInProgress = false;
        let animationSegmentIndex = 0;
        let animationPath = [];
        let animationPointIndex = 0;
        let animationFrameId = null;
        let tolerancia = 30

let userDrawnPaths = []; // Store all user paths for current letter
let currentUserPath = []; // Current path being drawn
let letterPaths = {
 "a": [
                {
                    "points": [
                        {"x": 60, "y": 200},
                        {"x": 140, "y": 60},
                       
                    ],
                    "color": "#514a00ff"
                },
               {
                    "points": [
                     
                        {"x": 140, "y": 60},
                        {"x": 220, "y": 200}
                    ],
                    "color": "#514a00ff"
                },
                {
                    "points": [
                        {"x": 60, "y": 160},
                        {"x": 220, "y": 160},
                    ],
                    "color": "#514a00ff"
                }
            ]
 }
 
        let strokeColors = ['#554726', '#554726', '#554726', '#554726', '#554726'];
        let colorIndex = 0;

document.addEventListener('mousemove', function(e) {
  const cursorElement = document.getElementById('cursor');
  if (cursorElement) { // Check if the element exists before trying to modify it
    cursorElement.style.left = e.pageX-26 + 'px';
    cursorElement.style.top = e.pageY-22+'px';
  }
});

function startcreative(){
     document.getElementById("intro").style.display = "none";
    setMode('create')
}
        // Bunny animation functions
        function flattenSegment(segment, pointsPerSegment = 3) {
            const points = segment.points;
            if (points.length < 2) return points;
            
            const flat = [];
            
            // Add first point
            flat.push({x: points[0].x, y: points[0].y});
            
            // Interpolate between each consecutive pair of points
            for (let i = 0; i < points.length - 1; i++) {
                const start = points[i];
                const end = points[i + 1];
                
                // Calculate distance to determine how many interpolation points we need
                const distance = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);
                const numPoints = Math.max(1, Math.floor(distance / 8)); // One point every 8 pixels
                
                for (let j = 1; j <= numPoints; j++) {
                    const t = j / numPoints;
                    const x = start.x + (end.x - start.x) * t;
                    const y = start.y + (end.y - start.y) * t;
                    flat.push({x: Math.round(x), y: Math.round(y)});
                }
            }
            
            return flat;
        }


        function drawBunny(x, y) {
            ctx.font = "30px serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("üê∞", x, y);
        }

        function drawDashedPath(points, upToIndex) {
            ctx.beginPath();
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.setLineDash([1, 10]);
            ctx.strokeStyle = "#4a5568";
            if (upToIndex > 0) {
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < upToIndex; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();
            }
            ctx.setLineDash([]);
        }











// Replace the animateSegment function with this fixed version:
function animateSegment() {
    if (!animationInProgress) return;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawLines();
    
    // Draw completed segments
    for (let i = 0; i < animationSegmentIndex; i++) {
        if (letterPaths[currentLetter][i]) {
            const segment = letterPaths[currentLetter][i];
            ctx.strokeStyle = segment.color;
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(segment.points[0].x, segment.points[0].y);
            for (let j = 1; j < segment.points.length; j++) {
                ctx.lineTo(segment.points[j].x, segment.points[j].y);
            }
            ctx.stroke();
        }
    }
    
    // Draw user's current path if they're drawing
    if (currentPath.length > 0 && currentMode === 'play') {
        ctx.strokeStyle = '#4a5568';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(currentPath[0].x, currentPath[0].y);
        for (let i = 1; i < currentPath.length; i++) {
            ctx.lineTo(currentPath[i].x, currentPath[i].y);
        }
        ctx.stroke();
    }
    
    // Only draw the current segment being animated
    drawDashedPath(animationPath, animationPointIndex);
    
    if (animationPointIndex < animationPath.length) {
        drawBunny(animationPath[animationPointIndex].x, animationPath[animationPointIndex].y);
        animationPointIndex++;
        // Use a fixed interval instead of recursive setTimeout
        animationFrameId = setTimeout(animateSegment, 80);
    } else {
        // Current segment animation complete - stop the animation loop
        drawBunny(animationPath[animationPath.length - 1].x, animationPath[animationPath.length - 1].y);
        // Don't continue the animation loop - just wait for user interaction
        showFeedback(`Siga o coelhinho! Tra√ßo ${animationSegmentIndex + 1}/${letterPaths[currentLetter].length} üê∞`, 'info');
    }
}


// Check if user drawing has reached the bunny (only while bunny is moving)
function checkIfReachedBunny(userPoint) {

    // Get bunny's current position
    const bunnyPosition = animationPath[animationPath.length-1];
    
    // Check if user drawing is close to bunny (within 30 pixels)
    const distanceToBunny = distance(userPoint, bunnyPosition);
    
    // Only trigger if user has drawn a reasonable amount (at least 8 points)
    // AND the bunny is still moving (hasn't reached the end yet)
    return distanceToBunny < 8 && currentPath.length >= 4;
}


// Update the clearCanvas function to work better with concurrent drawing:
function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawLines();
    if (currentMode === 'create') {
        currentStroke = [];
        redrawCanvas();
    } else {
        currentPath = [];
        completedSegments = [];
        updateProgress();
        // If in play mode and there's an active letter, restart animation
        if (letterPaths[currentLetter]) {
            setTimeout(() => {
                animationInProgress = true;
                animationSegmentIndex = currentPathIndex;
                animationPath = flattenSegment(letterPaths[currentLetter][currentPathIndex]);
                animationPointIndex = 0;
                animateSegment();
            }, 100);
        }
    }
}






        function updateEraseRadius(value) {
            eraseRadius = parseInt(value);
            document.getElementById('eraseRadiusValue').textContent = value + 'px';
        }

        function initCanvas() {
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', stopDrawing);
            document.addEventListener('keydown', handleKeyPress);
            
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            generateLetterButtons();
            selectLetter('a');
            startRecording();
        }

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (e.type === 'touchstart') {
                startDrawing({offsetX: x, offsetY: y});
            } else if (e.type === 'touchmove') {
                draw({offsetX: x, offsetY: y});
            }
        }

        function handleKeyPress(e) {
            if (e.key === '1' && currentMode === 'create' && isRecording && currentStroke.length > 0) {
                e.preventDefault();
                finishStroke();
                setTimeout(() => startRecording(), 100);
            }
        }
        
        function finishStroke() {
            if (currentStroke.length < 2) return;
            
            if (!letterPaths[currentLetter]) {
                letterPaths[currentLetter] = [];
            }
            
            letterPaths[currentLetter].push({
                points: currentStroke,
                color: strokeColors[colorIndex % strokeColors.length]
            });
            
            colorIndex++;
            isRecording = false;
            document.getElementById('recordingIndicator').classList.remove('active');
            
            updateStrokeList();
            updateLetterButton();
            setTimeout(() => startRecording(), 100);
        }
       
      

        function toggleEraseMode() {
            if (currentMode !== 'create') return;
            
            isEraseMode = !isEraseMode;
            const btn = document.getElementById('eraseModeBtn');
            
            if (isEraseMode) {
                btn.textContent = 'üí©';
                btn.className = 'btn-success';
               // canvas.style.cursor = 'crosshair';
                showFeedback('Modo limpeza ativado! Clique nos üí© para apag√°-los üóëÔ∏è', 'info');
                isRecording = false;
                document.getElementById('recordingIndicator').classList.remove('active');
            } else {
                btn.textContent = 'üóëÔ∏è';
                btn.className = 'btn-warning';
               // canvas.style.cursor = 'crosshair';
                showFeedback('Modo comunicar ativado! Continue üí©' ,' info');
                startRecording();
            }
        }

        function erasePointsNearCursor(cursorPoint) {
            if (!letterPaths[currentLetter]) {
                showFeedback('Nenhum desenho na arte"'+ currentLetter +'"!', 'info');
                return;
            }
            let pointsErased = false;
            
            letterPaths[currentLetter].forEach((stroke, strokeIndex) => {
                if (!stroke.points) return;
                
                const originalLength = stroke.points.length;
                stroke.points = stroke.points.filter(point => 
                    distance(point, cursorPoint) > eraseRadius
                );
                
                if (stroke.points.length !== originalLength) {
                    pointsErased = true;
                }
                
                if (stroke.points.length < 2) {
                    letterPaths[currentLetter].splice(strokeIndex, 1);
                }
            });
            
            if (pointsErased) {
                redrawCanvas();
                updateStrokeList();
                
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(cursorPoint.x, cursorPoint.y, eraseRadius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]);
                
                setTimeout(() => redrawCanvas(), 100);
            }
        }


        function drawLines() {
            ctx.fillStyle = '#b8cfffff';
            ctx.fillRect(0, 60, 320, 1);
            ctx.fillRect(0, 100, 320, 1);
            ctx.fillRect(0, 160, 320, 1);
            ctx.fillRect(0, 200, 320, 1);
            ctx.fillRect(0, 260, 320, 1);
            ctx.fillRect(0, 300, 320, 1);
        }

  

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawLines();
            
            if (letterPaths[currentLetter]) {
                letterPaths[currentLetter].forEach((stroke, index) => {
                    ctx.lineWidth = 3;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.setLineDash([1, 10]);
                    ctx.strokeStyle = "#4a5568";
                    ctx.beginPath();
                    ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                    for (let i = 1; i < stroke.points.length; i++) {
                        ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                    }
                    ctx.stroke();
                });
            }
        }
      
        function drawLetter() {
            if (animationInProgress) return; // Don't interfere with animation
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawLines();
            
            const paths = letterPaths[currentLetter];
            if (!paths) return;
            
            if (showingGuide) {
                const currentPath = paths[currentPathIndex];
                if (currentPath && currentPath.points && currentPath.points.length > 1) {
                    setTimeout(() => {
                        ctx.strokeStyle = currentPath.color;
                        ctx.lineWidth = 3;
                        ctx.setLineDash([1, 15]);
                        ctx.beginPath();
                        ctx.moveTo(currentPath.points[0].x, currentPath.points[0].y);
                        for (let i = 1; i < currentPath.points.length; i++) {
                            ctx.lineTo(currentPath.points[i].x, currentPath.points[i].y);
                        }
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Draw animated bunny at start point instead of green circle
                        drawBunny(currentPath.points[0].x, currentPath.points[0].y);
                        
                        // Draw directional arrows along the path
                        drawDirectionalArrows(currentPath.points, currentPath.color);
                        
                        // Draw end bunny (smaller) instead of red circle
                        ctx.font = "20px serif";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        const lastPoint = currentPath.points[currentPath.points.length - 1];
                        ctx.fillText("üê∞", lastPoint.x, lastPoint.y);
                        ctx.font = "30px serif"; // Reset font size
                    }, 50);
                }
            }
            
            // Draw completed segments
            completedSegments.forEach(index => {
                if (index < paths.length) {
                    drawCompletedSegment(index);
                }
            });
            
        }

        function drawDirectionalArrows(points, color) {
            if (points.length < 2) return;
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            const arrowCount = Math.min(3, Math.floor(points.length / 5));
            for (let i = 1; i <= arrowCount; i++) {
                const pointIndex = Math.floor((points.length - 1) * (i / (arrowCount + 1)));
                if (pointIndex > 0 && pointIndex < points.length - 1) {
                    const point = points[pointIndex];
                    const prevPoint = points[pointIndex - 1];
                    
                    const dx = point.x - prevPoint.x;
                    const dy = point.y - prevPoint.y;
                    const angle = Math.atan2(dy, dx);
                    
                    drawArrow(point.x, point.y, angle, 12, color);
                }
            }
        }

        function drawArrow(x, y, angle, size, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-size, -size/2);
            ctx.lineTo(-size/2, 0);
            ctx.lineTo(-size, size/2);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }

        function drawCompletedSegment(index) {
            const path = letterPaths[currentLetter][index];
            ctx.strokeStyle = '#00005599';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(path.points[0].x, path.points[0].y);
            for (let i = 1; i < path.points.length; i++) {
                ctx.lineTo(path.points[i].x, path.points[i].y);
            }
            ctx.stroke();
        }


        function checkPathDirection(userPath, startTarget, endTarget, startTolerance, endTolerance, minProgressPoints) {
            let startFound = false;
            let endFound = false;
            let startIndex = -1;
            let endIndex = -1;
            let progressPoints = 0;
            
            for (let i = 0; i < Math.min(userPath.length, 15); i++) {
                if (distance(userPath[i], startTarget) < startTolerance) {
                    startFound = true;
                    startIndex = i;
                    pathStarted = true;
                    break;
                }
            }
            
            if (!startFound) return false;
            
            for (let i = startIndex + minProgressPoints; i < userPath.length; i++) {
                if (distance(userPath[i], endTarget) < endTolerance) {
                    endFound = true;
                    endIndex = i;
                    progressPoints = endIndex - startIndex;
                    break;
                }
            }
            
            return startFound && endFound && progressPoints >= minProgressPoints;
        }

        function validateSinglePath(userPath, targetPoints) {
            if (userPath.length < 5 || targetPoints.length < 2) return false;
            
            const startPoint = targetPoints[0];
            const endPoint = targetPoints[targetPoints.length - 1];
            const startTolerance = 30;
            const endTolerance = 35;
            const middleTolerance = 40;
            const minProgressPoints = Math.floor(userPath.length * 0.3);
            
            const forwardValid = checkPathWithMiddlePoints(userPath, targetPoints, startTolerance, endTolerance, middleTolerance, minProgressPoints);
            const reverseValid = checkPathWithMiddlePoints(userPath, [...targetPoints].reverse(), startTolerance, endTolerance, middleTolerance, minProgressPoints);
            
            return forwardValid || reverseValid;
        }

        function checkPathWithMiddlePoints(userPath, targetPoints, startTolerance, endTolerance, middleTolerance, minProgressPoints) {
            if (targetPoints.length < 2) return false;
            
            const startPoint = targetPoints[0];
            const endPoint = targetPoints[targetPoints.length - 1];
            
            let startFound = false;
            let startIndex = -1;
            
            for (let i = 0; i < Math.min(userPath.length, 15); i++) {
                if (distance(userPath[i], startPoint) < startTolerance) {
                    startFound = true;
                    startIndex = i;
                    pathStarted = true;
                    break;
                }
            }
            
            if (!startFound) return false;
            
            let endFound = false;
            let endIndex = -1;
            
            for (let i = startIndex + minProgressPoints; i < userPath.length; i++) {
                if (distance(userPath[i], endPoint) < endTolerance) {
                    endFound = true;
                    endIndex = i;
                    break;
                }
            }
            
            if (!endFound) return false;
            
            const middlePointsValid = validateMiddlePoints(
                userPath.slice(startIndex, endIndex + 1), 
                targetPoints, 
                middleTolerance
            );
            
            return middlePointsValid;
        }

        function validateMiddlePoints(userPathSegment, targetPoints, tolerance) {
            if (targetPoints.length <= 2) return true;
            
            const checkpoints = createPathCheckpoints(targetPoints, 3);
            let passedCheckpoints = 0;
            
            for (const checkpoint of checkpoints) {
                if (userPassedThroughPoint(userPathSegment, checkpoint, tolerance)) {
                    passedCheckpoints++;
                }
            }
            
            const requiredCheckpoints = Math.max(1, Math.floor(checkpoints.length * 0.7));
            return passedCheckpoints >= requiredCheckpoints;
        }

        function createPathCheckpoints(targetPoints, minCheckpoints) {
            if (targetPoints.length <= 2) return [];
            
            const checkpoints = [];
            const totalPoints = targetPoints.length;
            
            const numCheckpoints = Math.max(minCheckpoints, Math.min(6, Math.floor(totalPoints / 3)));
            
            for (let i = 1; i < numCheckpoints + 1; i++) {
                const ratio = i / (numCheckpoints + 1);
                const pointIndex = Math.floor(ratio * (totalPoints - 1));
                
                if (pointIndex > 0 && pointIndex < totalPoints - 1) {
                    checkpoints.push({
                        point: targetPoints[pointIndex],
                        index: pointIndex,
                        ratio: ratio
                    });
                }
            }
            
            return checkpoints;
        }

        function userPassedThroughPoint(userPath, checkpoint, tolerance) {
            const targetPoint = checkpoint.point;
            
            for (const userPoint of userPath) {
                if (distance(userPoint, targetPoint) < tolerance) {
                    return true;
                }
            }
            
            return false;
        }

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function showGuide() {
            showingGuide = !showingGuide;
            drawLetter();
            showFeedback(showingGuide ? 'Guia mostrado! Siga os caminhos do coelhinho üê∞' : 'Guia escondido! Tente sozinho üí™', 'info');
        }

        function showFeedback(message, type) {
            const feedback = document.getElementById('feedback');
            feedback.textContent = message;
            feedback.className = `feedback ${type}`;
        }

       

        function updateProgress() {
            const totalPaths = letterPaths[currentLetter] ? letterPaths[currentLetter].length : 1;
            const progress = (currentPathIndex / totalPaths) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
        }

        function checkProgress() {
            updateProgress();
        }


        function getValidationFeedback(userPath, targetPoints) {
            const startPoint = targetPoints[0];
            const endPoint = targetPoints[targetPoints.length - 1];
            
            let startReached = false;
            let endReached = false;
            
            for (const point of userPath) {
                if (distance(point, startPoint) < 30) startReached = true;
                if (distance(point, endPoint) < 35) endReached = true;
            }
            
            if (!startReached) {
                return 'Comece pelo coelhinho grande! üê∞';
            } else if (!endReached) {
                return 'Continue at√© o coelhinho pequeno! üê∞';
            } else {
                return 'Siga o caminho mais de perto! Passe pelo meio do tra√ßo üéØ';
            }
        }

        function nextLetter() {
            document.getElementById('nextBtn').classList.add('hidden');
            const letters = Object.keys(letterPaths);
            const currentIndex = letters.indexOf(currentLetter);
            const nextIndex = (currentIndex + 1) % letters.length;
            selectLetter(letters[nextIndex]);
        }

        function generateLetterButtons() {
            const letterSelector = document.getElementById('letterSelector');
            letterSelector.innerHTML = '';
           
            Object.keys(letterPaths).forEach((letter, index) => {
                const button = document.createElement('button');
                button.className = 'letter-btn';
                button.dataset.letter = letter;
                button.textContent = letter;
               
                if (letter === currentLetter) {
                    button.classList.add('active');
                }
               
                button.addEventListener('mousedown', (e) => handleMouseDown(e, letter));
                button.addEventListener('mouseup', (e) => handleMouseUp(e, letter));
                button.addEventListener('mouseleave', () => handleMouseLeave(letter));
                
                button.addEventListener('touchstart', (e) => handleTouchStart(e, letter));
                button.addEventListener('touchend', (e) => handleTouchEnd(e, letter));
                
                letterSelector.appendChild(button);
            });
        }

        function promptForKeystroke() {
            const newKey = prompt(`Escolha o nome da arte para adicionar depois de "${currentLetter}":`);

            if (!newKey) {
                alert("Nenhuma letra digitada, opera√ß√£o cancelada.");
                return;
            }

            if (letterPaths.hasOwnProperty(newKey)) {
                alert(`"${newKey}" j√° existe.`);
                return;
            }

            const newLetterPaths = {};
            let inserted = false;

            for (const key in letterPaths) {
                newLetterPaths[key] = letterPaths[key];

                if (key === currentLetter){
                    newLetterPaths[newKey] = [];
                    inserted = true;
                }
            }

            if (!inserted) {
                alert(`"${currentLetter}" n√£o encontrada. Adicionando "${newKey}" ao final.`);
                newLetterPaths[newKey] = [];
            }
            letterPaths = newLetterPaths;
            generateLetterButtons();
        }

        function handleMouseDown(e, letter) {
            e.preventDefault();
            isLongPress = false;
            
            const button = e.target;
            button.classList.add('pressed');
            
            longPressTimer = setTimeout(() => {
                isLongPress = true;
                showPopupMenu(e, letter);
            }, 500);
        }

        function handleMouseUp(e, letter) {
            clearTimeout(longPressTimer);
            
            const button = e.target;
            button.classList.remove('pressed');
            
            if (!isLongPress) {
                setTimeout(() => selectLetter(letter), 50);
            }
        }

        function handleMouseLeave(letter) {
            clearTimeout(longPressTimer);
            const button = document.querySelector(`[data-letter="${letter}"]`);
            button.classList.remove('pressed');
        }

        function handleTouchStart(e, letter) {
            handleMouseDown(e, letter);
        }

        function handleTouchEnd(e, letter) {
            e.preventDefault();
            handleMouseUp(e, letter);
        }

        function showPopupMenu(e, letter) {
            hidePopupMenu();
            
            const menu = createPopupMenu(letter);
            document.body.appendChild(menu);
            
            const rect = e.target.getBoundingClientRect();
            const menuRect = menu.getBoundingClientRect();
            
            let left = rect.left;
            let top = rect.bottom + 5;
            
            if (left + menuRect.width > window.innerWidth) {
                left = window.innerWidth - menuRect.width - 10;
            }
            if (top + menuRect.height > window.innerHeight) {
                top = rect.top - menuRect.height - 5;
            }
            
            menu.style.left = left + 'px';
            menu.style.top = top + 'px';
            
            setTimeout(() => menu.classList.add('show'), 10);
            
            document.getElementById('popupOverlay').style.display = 'block';
            document.getElementById('popupOverlay').onclick = hidePopupMenu;
            
            currentPopupMenu = menu;
        }

        function createPopupMenu(letter) {
            const menu = document.createElement('div');
            menu.className = 'popup-menu';
            
            const keys = Object.keys(letterPaths);
            const currentIndex = keys.indexOf(letter);
            
            const moveLeftItem = document.createElement('div');
            moveLeftItem.className = `popup-menu-item move-left ${currentIndex === 0 ? 'disabled' : ''}`;
            moveLeftItem.innerHTML = '<span class="menu-icon">&lt;</span>Mover para esquerda';
            if (currentIndex > 0) {
                moveLeftItem.onclick = () => moveKey(letter, -1);
            }
            menu.appendChild(moveLeftItem);
            
            const moveRightItem = document.createElement('div');
            moveRightItem.className = `popup-menu-item move-right ${currentIndex === keys.length - 1 ? 'disabled' : ''}`;
            moveRightItem.innerHTML = '<span class="menu-icon">&gt;</span>Mover para direita';
            if (currentIndex < keys.length - 1) {
                moveRightItem.onclick = () => moveKey(letter, 1);
            }
            menu.appendChild(moveRightItem);
            
            const renameItem = document.createElement('div');
            renameItem.className = 'popup-menu-item rename';
            renameItem.innerHTML = '<span class="menu-icon">‚úèÔ∏è</span>Renomear';
            renameItem.onclick = () => renameKey(letter);
            menu.appendChild(renameItem);
            
            const deleteItem = document.createElement('div');
            deleteItem.className = 'popup-menu-item delete';
            deleteItem.innerHTML = '<span class="menu-icon">üóëÔ∏è</span>Excluir';
            deleteItem.onclick = () => deleteKey(letter);
            menu.appendChild(deleteItem);
            
            return menu;
        }

        function hidePopupMenu() {
            if (currentPopupMenu) {
                currentPopupMenu.classList.remove('show');
                setTimeout(() => {
                    if (currentPopupMenu && currentPopupMenu.parentNode) {
                        currentPopupMenu.parentNode.removeChild(currentPopupMenu);
                    }
                    currentPopupMenu = null;
                }, 200);
            }
            document.getElementById('popupOverlay').style.display = 'none';
        }

        function moveKey(letter, direction) {
            const keys = Object.keys(letterPaths);
            const currentIndex = keys.indexOf(letter);
            const newIndex = currentIndex + direction;
            
            if (newIndex >= 0 && newIndex < keys.length) {
                const newLetterPaths = {};
                const newKeys = [...keys];
                
                [newKeys[currentIndex], newKeys[newIndex]] = [newKeys[newIndex], newKeys[currentIndex]];
                
                newKeys.forEach(key => {
                    newLetterPaths[key] = letterPaths[key];
                });
                
                letterPaths = newLetterPaths;
                generateLetterButtons();
            }
            
            hidePopupMenu();
        }

        function renameKey(oldKey) {
            const newKey = prompt(`Renomear "${oldKey}" para:`, oldKey);
            
            if (newKey && newKey.trim() && newKey !== oldKey) {
                const trimmedKey = newKey.trim();
                
                if (letterPaths.hasOwnProperty(trimmedKey)) {
                    alert('Uma arte com este nome j√° existe!');
                    return;
                }
                
                const newLetterPaths = {};
                Object.keys(letterPaths).forEach(key => {
                    if (key === oldKey) {
                        newLetterPaths[trimmedKey] = letterPaths[key];
                    } else {
                        newLetterPaths[key] = letterPaths[key];
                    }
                });
                
                letterPaths = newLetterPaths;
                
                if (currentLetter === oldKey) {
                    currentLetter = trimmedKey;
                }
                
                generateLetterButtons();
            }
            
            hidePopupMenu();
        }

        function deleteKey(letter) {
            if (Object.keys(letterPaths).length === 1) {
                alert('N√£o √© poss√≠vel excluir a √∫ltima arte!');
                hidePopupMenu();
                return;
            }
            
            if (confirm(`Tem certeza que deseja excluir "${letter}"?`)) {
                delete letterPaths[letter];
                
                if (currentLetter === letter) {
                    currentLetter = Object.keys(letterPaths)[0];
                }
                
                generateLetterButtons();
            }
            
            hidePopupMenu();
        }

        function updateOrCreateLetterButton(key) {
            let button = document.querySelector(`[data-letter="${key}"]`);
            if (!button) {
                button = document.createElement('button');
                button.className = 'letter-btn';
                button.dataset.letter = key;
                button.textContent = key;
                button.addEventListener('click', () => selectLetter(key));
                document.getElementById('letterSelector').appendChild(button);
            }
            
            document.querySelectorAll('.letter-btn').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
        }

        function startRecording() {
            if (currentMode !== 'create') return;
            isRecording = true;
            currentStroke = [];
            document.getElementById('recordingIndicator').classList.add('active');
        }

        function setMode(mode) {
            // Stop any running animation when switching modes
            if (animationInProgress) {
                if (animationFrameId) {
                    clearTimeout(animationFrameId);
                }
                animationInProgress = false;
            }
            
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            //event.target.classList.add('active');
            
            if (isEraseMode) {
                isEraseMode = false;
                const eraseModeBtn = document.getElementById('eraseModeBtn');
                if (eraseModeBtn) {
                    eraseModeBtn.textContent = 'üóëÔ∏è Modo Apagar';
                    eraseModeBtn.className = 'btn-warning';
                }
            }
            
            if (mode === 'play') {
                document.getElementById('playMode').classList.remove('hidden');
                document.getElementById('createMode').classList.add('hidden');
                document.getElementById('playControls').classList.remove('hidden');
                document.getElementById('createControls').classList.add('hidden');
                document.getElementById('strokeList').classList.add('hidden');
                showingGuide = false;
                completedSegments = [];
                drawLetter();
                setTimeout(recomecar, 100);
            } else {
                document.getElementById('playMode').classList.add('hidden');
                document.getElementById('createMode').classList.remove('hidden');
                document.getElementById('playControls').classList.add('hidden');
                document.getElementById('createControls').classList.remove('hidden');
                document.getElementById('strokeList').classList.remove('hidden');
                startRecording();
                redrawCanvas();
            }
        }

        function newLetter() {
            if (letterPaths[currentLetter]) {
                delete letterPaths[currentLetter];
            }
            colorIndex = 0;
            clearCanvas();
            updateStrokeList();
            updateLetterButton();
        }

        function updateStrokeList() {
            const strokesDiv = document.getElementById('strokes');
            const strokeCount = document.getElementById('strokeCount');
            
            if (!letterPaths[currentLetter] || letterPaths[currentLetter].length === 0) {
                strokesDiv.innerHTML = 'Nenhum tra√ßo gravado ainda';
                strokeCount.textContent = '0';
                return;
            }
            
            strokeCount.textContent = letterPaths[currentLetter].length;
            
            let html = '';
            letterPaths[currentLetter].forEach((stroke, index) => {
                html += `<div style="color: ${stroke.color}">‚óè Tra√ßo ${index + 1} (${stroke.points.length} pontos)</div>`;
            });
            
            strokesDiv.innerHTML = html;
        }

        function updateLetterButton() {
            const button = document.querySelector(`[data-letter="${currentLetter}"]`);
            if (button) {
                if (letterPaths[currentLetter] && letterPaths[currentLetter].length > 0) {
                    button.classList.add('completed');
                } else {
                    button.classList.remove('completed');
                }
            }
        }

        function setHidden(obj){
            document.getElementById(obj).style.display = 'none';
        }

        
function exportJSON() {
    try {
        // Clean the data before exporting
        const cleanedPaths = {};
        Object.keys(letterPaths).forEach(key => {
            if (letterPaths[key] && Array.isArray(letterPaths[key])) {
                cleanedPaths[key] = letterPaths[key].map(stroke => ({
                    points: stroke.points || [],
                    color: stroke.color || '#514a00ee'
                }));
            }
        });
        
        const dataStr = JSON.stringify(cleanedPaths, null, 2);
        
        // Create blob with explicit UTF-8 encoding
        const blob = new Blob([dataStr], { 
            type: "application/json;charset=utf-8" 
        });
        
        // Use different download methods for mobile vs desktop
        if (/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            // Mobile-friendly download
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "DesenheACoisa.json";
            a.target = "_blank";
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        } else {
            // Desktop download
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "DesenheACoisa.json";
            
            a.style.display = "none";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            setTimeout(() => URL.revokeObjectURL(url), 100);
        }
        
        alert("Arquivo exportado com sucesso!");
        
    } catch (error) {
        console.error("Export failed:", error);
        alert("Falha na exporta√ß√£o: " + error.message);
    }
}

// Replace the file import event listener with this improved version:
document.getElementById("importFile").addEventListener("change", (event) => {
    const file = event.target.files[0];
    if (!file) return;
    
    if (!file.name.toLowerCase().endsWith('.json') && file.type !== 'application/json') {
        alert("Por favor, selecione um arquivo JSON v√°lido.");
        return;
    }
    
    if (file.size > 5 * 1024 * 1024) {
        alert("Arquivo muito grande. M√°ximo 5MB.");
        return;
    }
    
    const reader = new FileReader();
    
    reader.onerror = function() {
        alert("Erro ao ler o arquivo.");
    };
    
    reader.onload = function (e) {
        try {
            let result = e.target.result;
            
            // Remove BOM if present (common issue with mobile exports)
            result = result.replace(/^\uFEFF/, '');
            result = result.replace(/^\ufeff/, '');
            
            // Remove any invisible characters that might cause issues
            result = result.replace(/[\u200B-\u200D\uFEFF]/g, '');
            
            // Trim whitespace
            result = result.trim();
            
            if (!result || typeof result !== 'string') {
                throw new Error("Conte√∫do do arquivo inv√°lido");
            }
           
            const importedData = JSON.parse(result);
            
            if (!importedData || typeof importedData !== 'object') {
                throw new Error("Estrutura de dados inv√°lida");
            }
            
            // Validate and clean imported data
            const validatedData = {};
            Object.keys(importedData).forEach(key => {
                if (Array.isArray(importedData[key])) {
                    validatedData[key] = importedData[key].map(stroke => ({
                        points: Array.isArray(stroke.points) ? stroke.points : [],
                        color: stroke.color || '#514a00ee'
                    }));
                }
            });
            
            // Clear the file input
            event.target.value = '';
            
            // Update letterPaths
            letterPaths = validatedData;
            generateLetterButtons();
            
            const firstKey = Object.keys(letterPaths)[0];
            if (firstKey) {
                selectLetter(firstKey);
            }
            
            alert("Importa√ß√£o bem-sucedida!");
            
        } catch (err) {
            console.error("Import failed:", err);
            alert("Falha ao importar JSON: " + err.message + "\nTente usar a op√ß√£o 'Colar' para importar manualmente.");
        }
    };
    
    // Read as text with UTF-8 encoding
    reader.readAsText(file, 'UTF-8');
});

// Replace the processManualImport function with this improved version:
function processManualImport() {
    let text = document.getElementById("manualImportText").value;
    
    if (!text || !text.trim()) {
        alert("Cole o conte√∫do JSON na √°rea de texto.");
        return;
    }
    
    try {
        // Clean the text input similar to file import
        text = text.replace(/^\uFEFF/, '');
        text = text.replace(/^\ufeff/, '');
        text = text.replace(/[\u200B-\u200D\uFEFF]/g, '');
        text = text.trim();
        
        const importedData = JSON.parse(text);
        
        if (!importedData || typeof importedData !== 'object') {
            throw new Error("Estrutura de dados inv√°lida");
        }
        
        // Validate and clean imported data
        const validatedData = {};
        Object.keys(importedData).forEach(key => {
            if (Array.isArray(importedData[key])) {
                validatedData[key] = importedData[key].map(stroke => ({
                    points: Array.isArray(stroke.points) ? stroke.points : [],
                    color: stroke.color || '#514a00ee'
                }));
            }
        });
        
        letterPaths = validatedData;
        generateLetterButtons();
        
        const firstKey = Object.keys(letterPaths)[0];
        if (firstKey) {
            selectLetter(firstKey);
        }
        
        alert("Importa√ß√£o manual bem-sucedida!");
        document.getElementById("manualImportText").value = '';
        toggleManualImport();
        
    } catch (err) {
        console.error("Manual import failed:", err);
        alert("JSON inv√°lido: " + err.message);
    }
}



        function copyToClipboard() {
            const code = document.getElementById('generatedCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                alert('Code copied to clipboard! You can now replace the letterPaths in your handwriting game.');
            }).catch(() => {
                const textArea = document.createElement('textarea');
                textArea.value = code;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Code copied to clipboard!');
            });
        }

        function exportAllLetters() {
            if (Object.keys(letterPaths).length === 0) {
                alert('No letters recorded yet!');
                return;
            }
            
            const exportedPaths = {};
            
            Object.keys(letterPaths).forEach(letter => {
                exportedPaths[letter] = letterPaths[letter].map(stroke => ({
                    points: stroke.points,
                    color: stroke.color
                }));
            });
            
            const codeOutput = `${JSON.stringify(exportedPaths, null, 2)}`;
            
            document.getElementById('generatedCode').textContent = codeOutput;
            document.getElementById('outputArea').style.display = 'block';
            
            document.getElementById('outputArea').scrollIntoView({ behavior: 'smooth' });
        }

        function toggleManualImport() {
            const area = document.getElementById("manualImportArea");
            area.style.display = area.style.display === "none" ? "block" : "none";
        }


        initCanvas();
        
function newAlphabet(lowercase){
    let alphabet = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"]
     
    for(i in alphabet){
        if(lowercase == "a"){

            updateOrCreateLetterButton(alphabet[i])
        }
        else if(lowercase == "A"){
            var upperCase = alphabet[i]
            updateOrCreateLetterButton( upperCase.toUpperCase())
        }
 
    }            
}

function forca(){
    const palavras = ["banana", "macaco", "floresta"]
    let palavradavez = palavras[0]
    let letradavez = prompt("qual a letra?")
    if  ( letterPaths(letradavez)){
        selectLetter(letradavez)
    }else{
        alert("letra inexistente no repertorio. favor criar letra antes ou carregar arquivo com alfabeto completo")
    }
 
}
function startGame() {
    document.getElementById("intro").style.display = "none";
    setMode('play');
}
// Add this function to import JSON from URL
async function importFromURL(url) {
    try {
        showFeedback('Carregando dados da URL...', 'info');
        
        const response = await fetch(url);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const importedData = await response.json();
        
        if (!importedData || typeof importedData !== 'object') {
            throw new Error("Estrutura de dados inv√°lida");
        }
        
        // Validate and clean imported data
        const validatedData = {};
        Object.keys(importedData).forEach(key => {
            if (Array.isArray(importedData[key])) {
                validatedData[key] = importedData[key].map(stroke => ({
                    points: Array.isArray(stroke.points) ? stroke.points : [],
                    color: stroke.color || '#514a00ee'
                }));
            }
        });
        
        // Update letterPaths
        letterPaths = validatedData;
        generateLetterButtons();
        
        const firstKey = Object.keys(letterPaths)[0];
        if (firstKey) {
            selectLetter(firstKey);
        }
        
        showFeedback(`Importa√ß√£o bem-sucedida! ${Object.keys(validatedData).length} arte(s) carregada(s)`, 'success');
        setMode('play')
    } catch (error) {
        console.error("URL import failed:", error);
        showFeedback(`Falha ao importar da URL: ${error.message}`, 'error');
    }
}




















// Replace the startDrawing function with this updated version:
function startDrawing(e) {
    isDrawing = true;
    const point = {x: Math.round(e.offsetX), y: Math.round(e.offsetY)};
    
    if (currentMode === 'create') {
        if (isEraseMode) {
            erasePointsNearCursor(point);
            return;
        }
        
        if (!isRecording) return;
        currentStroke = [point];
        ctx.strokeStyle = strokeColors[colorIndex % strokeColors.length];
        ctx.beginPath();
        ctx.moveTo(point.x, point.y);
    } else {
        // In play mode, start recording user path
        currentUserPath = [point];
        currentPath = [point];
        // Clear any previous user strokes from the current drawing attempt
        if (animationInProgress) {
            // Redraw everything to clear previous user attempts
            setTimeout(() => animateSegment(), 0);
        }
    }
}

// Replace the draw function with this updated version:
function draw(e) {
    if (!isDrawing) return;
    
    const point = {x: Math.round(e.offsetX), y: Math.round(e.offsetY)};
    
    if (currentMode === 'create') {
        if (isEraseMode) {
            erasePointsNearCursor(point);
            return;
        }
        
        if (!isRecording) return;
        
        if (currentStroke.length > 0) {
            const lastPoint = currentStroke[currentStroke.length - 1];
            const dist = distance(point, lastPoint);
            if (dist < 8) return;
        }
       
        currentStroke.push(point);
        ctx.lineTo(point.x, point.y);
        ctx.stroke();
    } else {
        // Record user path
        currentUserPath.push(point);
        currentPath.push(point);
        
        ctx.strokeStyle = '#4a5568';
        ctx.lineWidth = 4;
        
        if (currentPath.length > 1) {
            const prevPoint = currentPath[currentPath.length - 2];
            ctx.beginPath();
            ctx.moveTo(prevPoint.x, prevPoint.y);
            ctx.lineTo(point.x, point.y);
            ctx.stroke();
        }
        
        // Check if user drawing has caught up with the bunny
        if (checkIfReachedBunny(point)) {
            // Clear any existing timeout to prevent speed accumulation
            if (animationFrameId) {
                clearTimeout(animationFrameId);
                animationFrameId = null;
            }
            
            stopDrawing();
            // Add a small delay before restarting to prevent immediate re-triggering
            setTimeout(() => {
                if (!isDrawing) { // Only restart if user isn't still drawing
                    startDrawing(point);
                }
            }, 50);
        }
        
        // Check progress regardless of animation state
        checkProgress();
    }
}

// Replace the stopDrawing function with this updated version:
function stopDrawing() {
    if (isDrawing) {
        isDrawing = false;
        if (currentMode === 'create') {
            finishStroke();
        } else {
            // Store the user's completed path
            if (currentUserPath.length > 0) {
                userDrawnPaths.push([...currentUserPath]);
                currentUserPath = [];
            }
            // In play mode, validate the path even during animation
            validatePath();
        }
    }
}

// Add this new function to show the comparison
function showUserPathComparison() {
    if (!letterPaths[currentLetter] || userDrawnPaths.length === 0) return;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawLines();
    
    // Draw the target paths (correct paths) in green
    letterPaths[currentLetter].forEach((segment, index) => {
      //  ctx.strokeStyle = '#27ae60'; // Green for correct path
        ctx.lineWidth = 6;
        ctx.globalAlpha = 0.2;
        ctx.setLineDash([1,12]);
        ctx.beginPath();
        ctx.moveTo(segment.points[0].x, segment.points[0].y);
        for (let j = 1; j < segment.points.length; j++) {
            ctx.lineTo(segment.points[j].x, segment.points[j].y);
        }
        ctx.stroke();
    });
    
    // Draw user's paths in red
    userDrawnPaths.forEach((userPath, index) => {
        if (userPath.length > 1) {
           // ctx.strokeStyle = '#e74c3c'; // Red for user path
            ctx.lineWidth = 4;
            ctx.globalAlpha = 0.8;
            ctx.setLineDash([]); // Dashed line for user path
            ctx.beginPath();
            ctx.moveTo(userPath[0].x, userPath[0].y);
            for (let i = 1; i < userPath.length; i++) {
                ctx.lineTo(userPath[i].x, userPath[i].y);
            }
            ctx.stroke();
        }
    });
  
}

// Replace the validatePath function with this updated version:
function validatePath() {
    if (currentPath.length < 5) return;
    
    const paths = letterPaths[currentLetter];
    if (!paths || paths.length === 0) return;
    
    const targetPath = paths[currentPathIndex];
    if (!targetPath) return;
    
    const isValid = validateSinglePath(currentPath, targetPath.points);
    
    if (isValid) {
        if (!completedSegments.includes(currentPathIndex)) {
            completedSegments.push(currentPathIndex);
        }
        
        currentPathIndex++;
        pathStarted = false;
        currentPath = [];
        
        // Stop current animation
        if (animationFrameId) {
            clearTimeout(animationFrameId);
        }
        
        if (currentPathIndex >= paths.length) {
            // All segments completed - show comparison after delay
            animationInProgress = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawLines();
            
            // Draw all completed segments
            for (let i = 0; i < paths.length; i++) {
                const segment = paths[i];
                ctx.strokeStyle = segment.color;
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(segment.points[0].x, segment.points[0].y);
                for (let j = 1; j < segment.points.length; j++) {
                    ctx.lineTo(segment.points[j].x, segment.points[j].y);
                }
                ctx.stroke();
            }
            
            showFeedback('Perfeito! Voc√™ completou "'+ currentLetter +'"! üéâ', 'success');
            document.querySelector('.container').classList.add('celebrate');
            
            // Show comparison after 1 second
            setTimeout(() => {
                showUserPathComparison();
                document.querySelector('.container').classList.remove('celebrate');
                document.getElementById('nextBtn').classList.remove('hidden');
            }, 1000);
            
        } else {
            // Start animation for the next segment immediately
            showFeedback(`√ìtimo! Pr√≥ximo tra√ßo (${currentPathIndex + 1}/${paths.length}) üåü`, 'success');
            setTimeout(() => {
                animationInProgress = true;
                animationSegmentIndex = currentPathIndex;
                animationPath = flattenSegment(letterPaths[currentLetter][currentPathIndex]);
                animationPointIndex = 0;
                animateSegment();
            }, 20);
        }
    } else {
        // Path is invalid - give feedback but allow user to continue or restart
        if (pathStarted) {
            const feedback = getValidationFeedback(currentPath, targetPath.points);
            showFeedback(feedback + ' Tente novamente! üîÑ', 'error');
        }
        // Clear the invalid path and let user start over
        currentPath = [];
    }
    
    updateProgress();
}

// Replace the selectLetter function to reset user paths:
function selectLetter(letter) {
    if (isLongPress) return;
    
    // Stop any running animation
    if (animationInProgress) {
        if (animationFrameId) {
            clearTimeout(animationFrameId);
        }
        animationInProgress = false;
    }
    
    currentLetter = letter;
    currentPathIndex = 0;
    pathStarted = false;
    
    // Reset user drawn paths for new letter
    userDrawnPaths = [];
    currentUserPath = [];
    
    if (currentMode === 'create') {
        document.getElementById('currentLetter').textContent = letter;
        document.getElementById('statusLetter').textContent = letter;
        redrawCanvas();
        updateStrokeList();
    } else {
        completedSegments = [];
        showingGuide = false;
        updateProgress();
        drawLetter();
        
        // Start animation for the first segment
        setTimeout(() => {
            animationInProgress = true;
            animationSegmentIndex = 0;
            animationPath = flattenSegment(letterPaths[letter][0]);
            animationPointIndex = 0;
            animateSegment();
        }, 300);

        const pathCount = letterPaths[letter] ? letterPaths[letter].length : 0;
        showFeedback(`Desenhe: ${letter}! (${pathCount} tra√ßo${pathCount !== 1 ? 's' : ''})`, 'info');
    }
    
    document.querySelectorAll('.letter-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.letter === letter) {
            btn.classList.add('active');
        }
    });
    
    colorIndex = 0;
}

// Replace the recomecar function to reset user paths:
function recomecar() {
    // Stop any running animation
    if (animationInProgress) {
        if (animationFrameId) {
            clearTimeout(animationFrameId);
        }
        animationInProgress = false;
    }
    
    currentPathIndex = 0;
    pathStarted = false;
    completedSegments = [];
    currentPath = [];
    
    // Reset user drawn paths
    userDrawnPaths = [];
    currentUserPath = [];
    
    // Restart from the beginning
    setTimeout(() => {
        animationInProgress = true;
        animationSegmentIndex = 0;
        animationPath = flattenSegment(letterPaths[currentLetter][0]);
        animationPointIndex = 0;
        animateSegment();
    }, 100);
    
    updateProgress();
    showFeedback(`Reiniciando ${currentLetter}! Siga o coelhinho! üê∞`, 'info');
}







































// Function to import the specific fbmsg.json file
function importFunnyBunnyMessage() {
    const url = 'https://diegoferraribruno.github.io/fbmsg.json';
    importFromURL(url);
}
 setTimeout(importFunnyBunnyMessage(),1000)
    </script>
</body>
</html>